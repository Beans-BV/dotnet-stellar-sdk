// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

namespace StellarDotnetSdk.Xdr;

// === xdr source ============================================================

//  struct ExistenceProofBody
//  {
//      LedgerKey keysToProve<>;
//  
//      // Bounds for each key being proved, where bound[n]
//      // corresponds to keysToProve[n]
//      ColdArchiveBucketEntry lowBoundEntries<>;
//      ColdArchiveBucketEntry highBoundEntries<>;
//  
//      // Vector of vectors, where proofLevels[level]
//      // contains all HashNodes that correspond with that level
//      ProofLevel proofLevels<>;
//  };

//  ===========================================================================
public class ExistenceProofBody
{
    public LedgerKey[] KeysToProve { get; set; }
    public ColdArchiveBucketEntry[] LowBoundEntries { get; set; }
    public ColdArchiveBucketEntry[] HighBoundEntries { get; set; }
    public ProofLevel[] ProofLevels { get; set; }

    public static void Encode(XdrDataOutputStream stream, ExistenceProofBody encodedExistenceProofBody)
    {
        var keysToProvesize = encodedExistenceProofBody.KeysToProve.Length;
        stream.WriteInt(keysToProvesize);
        for (var i = 0; i < keysToProvesize; i++)
        {
            LedgerKey.Encode(stream, encodedExistenceProofBody.KeysToProve[i]);
        }
        var lowBoundEntriessize = encodedExistenceProofBody.LowBoundEntries.Length;
        stream.WriteInt(lowBoundEntriessize);
        for (var i = 0; i < lowBoundEntriessize; i++)
        {
            ColdArchiveBucketEntry.Encode(stream, encodedExistenceProofBody.LowBoundEntries[i]);
        }
        var highBoundEntriessize = encodedExistenceProofBody.HighBoundEntries.Length;
        stream.WriteInt(highBoundEntriessize);
        for (var i = 0; i < highBoundEntriessize; i++)
        {
            ColdArchiveBucketEntry.Encode(stream, encodedExistenceProofBody.HighBoundEntries[i]);
        }
        var proofLevelssize = encodedExistenceProofBody.ProofLevels.Length;
        stream.WriteInt(proofLevelssize);
        for (var i = 0; i < proofLevelssize; i++)
        {
            ProofLevel.Encode(stream, encodedExistenceProofBody.ProofLevels[i]);
        }
    }

    public static ExistenceProofBody Decode(XdrDataInputStream stream)
    {
        var decodedExistenceProofBody = new ExistenceProofBody();
        var keysToProvesize = stream.ReadInt();
        decodedExistenceProofBody.KeysToProve = new LedgerKey[keysToProvesize];
        for (var i = 0; i < keysToProvesize; i++)
        {
            decodedExistenceProofBody.KeysToProve[i] = LedgerKey.Decode(stream);
        }
        var lowBoundEntriessize = stream.ReadInt();
        decodedExistenceProofBody.LowBoundEntries = new ColdArchiveBucketEntry[lowBoundEntriessize];
        for (var i = 0; i < lowBoundEntriessize; i++)
        {
            decodedExistenceProofBody.LowBoundEntries[i] = ColdArchiveBucketEntry.Decode(stream);
        }
        var highBoundEntriessize = stream.ReadInt();
        decodedExistenceProofBody.HighBoundEntries = new ColdArchiveBucketEntry[highBoundEntriessize];
        for (var i = 0; i < highBoundEntriessize; i++)
        {
            decodedExistenceProofBody.HighBoundEntries[i] = ColdArchiveBucketEntry.Decode(stream);
        }
        var proofLevelssize = stream.ReadInt();
        decodedExistenceProofBody.ProofLevels = new ProofLevel[proofLevelssize];
        for (var i = 0; i < proofLevelssize; i++)
        {
            decodedExistenceProofBody.ProofLevels[i] = ProofLevel.Decode(stream);
        }
        return decodedExistenceProofBody;
    }
}
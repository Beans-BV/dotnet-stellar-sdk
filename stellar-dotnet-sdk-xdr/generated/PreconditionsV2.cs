// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

namespace stellar_dotnet_sdk.xdr;

// === xdr source ============================================================

//  struct PreconditionsV2
//  {
//      TimeBounds* timeBounds;
//  
//      // Transaction only valid for ledger numbers n such that
//      // minLedger <= n < maxLedger (if maxLedger == 0, then
//      // only minLedger is checked)
//      LedgerBounds* ledgerBounds;
//  
//      // If NULL, only valid when sourceAccount's sequence number
//      // is seqNum - 1.  Otherwise, valid when sourceAccount's
//      // sequence number n satisfies minSeqNum <= n < tx.seqNum.
//      // Note that after execution the account's sequence number
//      // is always raised to tx.seqNum, and a transaction is not
//      // valid if tx.seqNum is too high to ensure replay protection.
//      SequenceNumber* minSeqNum;
//  
//      // For the transaction to be valid, the current ledger time must
//      // be at least minSeqAge greater than sourceAccount's seqTime.
//      Duration minSeqAge;
//  
//      // For the transaction to be valid, the current ledger number
//      // must be at least minSeqLedgerGap greater than sourceAccount's
//      // seqLedger.
//      uint32 minSeqLedgerGap;
//  
//      // For the transaction to be valid, there must be a signature
//      // corresponding to every Signer in this array, even if the
//      // signature is not otherwise required by the sourceAccount or
//      // operations.
//      SignerKey extraSigners<2>;
//  };

//  ===========================================================================
public class PreconditionsV2
{
    public TimeBounds TimeBounds { get; set; }
    public LedgerBounds LedgerBounds { get; set; }
    public SequenceNumber MinSeqNum { get; set; }
    public Duration MinSeqAge { get; set; }
    public Uint32 MinSeqLedgerGap { get; set; }
    public SignerKey[] ExtraSigners { get; set; }

    public static void Encode(XdrDataOutputStream stream, PreconditionsV2 encodedPreconditionsV2)
    {
        if (encodedPreconditionsV2.TimeBounds != null)
        {
            stream.WriteInt(1);
            TimeBounds.Encode(stream, encodedPreconditionsV2.TimeBounds);
        }
        else
        {
            stream.WriteInt(0);
        }

        if (encodedPreconditionsV2.LedgerBounds != null)
        {
            stream.WriteInt(1);
            LedgerBounds.Encode(stream, encodedPreconditionsV2.LedgerBounds);
        }
        else
        {
            stream.WriteInt(0);
        }

        if (encodedPreconditionsV2.MinSeqNum != null)
        {
            stream.WriteInt(1);
            SequenceNumber.Encode(stream, encodedPreconditionsV2.MinSeqNum);
        }
        else
        {
            stream.WriteInt(0);
        }

        Duration.Encode(stream, encodedPreconditionsV2.MinSeqAge);
        Uint32.Encode(stream, encodedPreconditionsV2.MinSeqLedgerGap);
        var extraSignerssize = encodedPreconditionsV2.ExtraSigners.Length;
        stream.WriteInt(extraSignerssize);
        for (var i = 0; i < extraSignerssize; i++) SignerKey.Encode(stream, encodedPreconditionsV2.ExtraSigners[i]);
    }

    public static PreconditionsV2 Decode(XdrDataInputStream stream)
    {
        var decodedPreconditionsV2 = new PreconditionsV2();
        var TimeBoundsPresent = stream.ReadInt();
        if (TimeBoundsPresent != 0) decodedPreconditionsV2.TimeBounds = TimeBounds.Decode(stream);
        var LedgerBoundsPresent = stream.ReadInt();
        if (LedgerBoundsPresent != 0) decodedPreconditionsV2.LedgerBounds = LedgerBounds.Decode(stream);
        var MinSeqNumPresent = stream.ReadInt();
        if (MinSeqNumPresent != 0) decodedPreconditionsV2.MinSeqNum = SequenceNumber.Decode(stream);
        decodedPreconditionsV2.MinSeqAge = Duration.Decode(stream);
        decodedPreconditionsV2.MinSeqLedgerGap = Uint32.Decode(stream);
        var extraSignerssize = stream.ReadInt();
        decodedPreconditionsV2.ExtraSigners = new SignerKey[extraSignerssize];
        for (var i = 0; i < extraSignerssize; i++) decodedPreconditionsV2.ExtraSigners[i] = SignerKey.Decode(stream);
        return decodedPreconditionsV2;
    }
}